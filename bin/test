#!/usr/bin/env python3.2

from operator import itemgetter
import json
import csv
import os.path


from hivclustering import *
from networkbuild import *

if __name__=='__main__':
     
    # Instead of reading from an input file, create my own cluster in
    # order to test algorithms

    #Create a transmission network
    network = transmission_network()

    #Add the nodes
    attrib = None
    network.insert_patient('Andre',False, False, attrib)
    network.insert_patient('Beverly',False, False, attrib)
    network.insert_patient('Carol',False, False, attrib)
    network.insert_patient('Diane',False, False, attrib)
    network.insert_patient('Ed',False, False, attrib)
    network.insert_patient('Fernando',False, False, attrib)
    network.insert_patient('Garth',False, False, attrib)
    network.insert_patient('Heather',False, False, attrib)
    network.insert_patient('Ike',False, False, attrib)

    #Add the edges
    network.add_an_edge('Andre', 'Carol', 1, parsePlain)
    network.add_an_edge('Andre', 'Diane', 1, parsePlain)
    network.add_an_edge('Andre', 'Fernando', 1, parsePlain)
    network.add_an_edge('Beverly', 'Diane', 1, parsePlain)
    network.add_an_edge('Beverly', 'Ed', 1, parsePlain)
    network.add_an_edge('Beverly', 'Garth', 1, parsePlain)
    network.add_an_edge('Carol', 'Diane', 1, parsePlain)
    network.add_an_edge('Carol', 'Fernando', 1, parsePlain)
    network.add_an_edge('Diane', 'Ed', 1, parsePlain)
    network.add_an_edge('Diane', 'Fernando', 1, parsePlain)
    network.add_an_edge('Diane', 'Garth', 1, parsePlain)
    network.add_an_edge('Ed', 'Garth', 1, parsePlain)
    network.add_an_edge('Fernando', 'Garth', 1, parsePlain)
    network.add_an_edge('Fernando', 'Heather', 1, parsePlain)
    network.add_an_edge('Garth', 'Heather', 1, parsePlain)
    network.add_an_edge('Heather', 'Ike', 1, parsePlain)
    network.add_an_edge('Ike', 'Jane', 1, parsePlain)

    centralities = [network.betweenness_centrality(i) for i in range(10)]
    print(centralities)
    
    #normal = map(lambda x: (x[0], (x[1] - min(centralities, key=itemgetter(1))[1])/(max(centralities, key=itemgetter(1))[1] - min(centralities, key=itemgetter(1))[1])), centralities)
    #import pprint
    #pprint.pprint(sorted(list(normal),key=lambda student: student[1], reverse=True))


    #print(network.betweenness_centrality())
    #print ("\t".join(["ClusterID","NodeID","MeanPathLength","RelativeToClusterMin","ClusterSize"]))
    #for cid, a_cluster in network.retrieve_clusters(singletons = False).items():
    #    paths = network.compute_shortest_paths(subset = a_cluster)
    #    #print (paths)
    #    paths = network.compute_path_stat(paths)
    #    min_d = min(paths.values())
    #    for n, d in paths.items():
    #        network.has_node_with_id(n.id).set_label ("%2.3g" % d)
    #        print ("%d\t%s\t%g\t%g\t%d" % (cid, n.id, d,d/min_d, len (a_cluster)))
